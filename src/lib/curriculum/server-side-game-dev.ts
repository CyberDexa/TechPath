import { Track } from "./types";

export const serverSideGameDevTrack: Track = {
  id: "server-side-game-dev",
  title: "Server-Side Game Developer",
  description:
    "Build the backend systems that power multiplayer games. Master networking, game servers, matchmaking, real-time synchronization, and scalable game infrastructure.",
  icon: "Server",
  color: "orange",
  category: "gaming",
  modules: [
    {
      id: "ssg-fundamentals",
      title: "Game Networking Fundamentals",
      description: "Core networking concepts for multiplayer games.",
      icon: "Network",
      trackId: "server-side-game-dev",
      order: 1,
      lessons: [
        {
          id: "ssg-fund-1",
          title: "Client-Server Architecture for Games",
          description: "Authoritative servers, dedicated vs listen servers, and architecture patterns.",
          duration: "12 min",
          hasTerminal: false,
        },
        {
          id: "ssg-fund-2",
          title: "TCP, UDP & Game Protocols",
          description: "Transport layer choices for games and custom protocol design.",
          duration: "15 min",
          hasTerminal: true,
          terminalExercise: {
            instructions: "Create a UDP socket server in Python that receives and echoes game messages.",
            validation: "socket|AF_INET|SOCK_DGRAM|recvfrom|sendto",
          },
        },
        {
          id: "ssg-fund-3",
          title: "Network Latency & Compensation",
          description: "Lag compensation, client-side prediction, and interpolation.",
          duration: "12 min",
          hasTerminal: false,
        },
        {
          id: "ssg-fund-4",
          title: "Serialization & Message Formats",
          description: "Protobuf, FlatBuffers, and custom binary serialization for game data.",
          duration: "12 min",
          hasTerminal: true,
          terminalExercise: {
            instructions: "Implement binary serialization for game state messages (position, rotation, health).",
            validation: "struct|pack|unpack|bytes|serialize",
          },
        },
      ],
      project: {
        title: "Chat Server",
        description: "Build a real-time chat server using UDP sockets as a foundation for game networking.",
        difficulty: "beginner",
        estimatedHours: 4,
        skills: ["Networking", "UDP", "Serialization"],
      },
    },
    {
      id: "ssg-game-servers",
      title: "Game Server Development",
      description: "Build authoritative game servers.",
      icon: "HardDrive",
      trackId: "server-side-game-dev",
      order: 2,
      lessons: [
        {
          id: "ssg-serv-1",
          title: "Game Server Architecture",
          description: "Tick-based servers, authoritative state, and server game loops.",
          duration: "15 min",
          hasTerminal: true,
          terminalExercise: {
            instructions: "Implement a tick-based game server loop that processes input, simulates game state, and broadcasts updates.",
            validation: "tick|while|sleep|broadcast|game_state|clients",
          },
        },
        {
          id: "ssg-serv-2",
          title: "Player Session Management",
          description: "Connections, disconnections, reconnection, and session tracking.",
          duration: "12 min",
          hasTerminal: false,
        },
        {
          id: "ssg-serv-3",
          title: "World Simulation",
          description: "Server-side physics, collision detection, and game world state.",
          duration: "12 min",
          hasTerminal: false,
        },
        {
          id: "ssg-serv-4",
          title: "Anti-Cheat Fundamentals",
          description: "Server-side validation, movement checks, and rate limiting.",
          duration: "10 min",
          hasTerminal: true,
          terminalExercise: {
            instructions: "Implement server-side movement validation that rejects impossible player movements.",
            validation: "validate|speed|max_speed|position|reject|distance",
          },
        },
      ],
      project: {
        title: "Authoritative Game Server",
        description: "Build an authoritative game server that manages game state for a simple multiplayer game.",
        difficulty: "intermediate",
        estimatedHours: 8,
        skills: ["Game Servers", "Networking", "Simulation"],
      },
    },
    {
      id: "ssg-realtime",
      title: "Real-Time Multiplayer",
      description: "Synchronization and real-time networking techniques.",
      icon: "Radio",
      trackId: "server-side-game-dev",
      order: 3,
      lessons: [
        {
          id: "ssg-rt-1",
          title: "State Synchronization",
          description: "Full state, delta compression, and snapshot interpolation.",
          duration: "15 min",
          hasTerminal: false,
        },
        {
          id: "ssg-rt-2",
          title: "Client-Side Prediction & Reconciliation",
          description: "Predicting actions locally and reconciling with server state.",
          duration: "15 min",
          hasTerminal: true,
          terminalExercise: {
            instructions: "Implement client-side prediction with server reconciliation for player movement.",
            validation: "predict|reconcile|server_state|pending_inputs|sequence",
          },
        },
        {
          id: "ssg-rt-3",
          title: "Entity Interpolation",
          description: "Smoothly rendering other players between server updates.",
          duration: "12 min",
          hasTerminal: false,
        },
        {
          id: "ssg-rt-4",
          title: "WebSocket & WebRTC for Games",
          description: "Browser-based multiplayer with WebSocket and WebRTC.",
          duration: "12 min",
          hasTerminal: true,
          terminalExercise: {
            instructions: "Build a WebSocket-based game server using Node.js that synchronizes player positions.",
            validation: "WebSocket|ws|onmessage|broadcast|position|JSON",
          },
        },
      ],
      project: {
        title: "Real-Time Multiplayer Demo",
        description: "Build a browser-based real-time multiplayer game with prediction, reconciliation, and interpolation.",
        difficulty: "advanced",
        estimatedHours: 10,
        skills: ["WebSocket", "State Sync", "Prediction"],
      },
    },
    {
      id: "ssg-matchmaking",
      title: "Matchmaking & Lobbies",
      description: "Building matchmaking systems and lobby management.",
      icon: "Users",
      trackId: "server-side-game-dev",
      order: 4,
      lessons: [
        {
          id: "ssg-mm-1",
          title: "Matchmaking Algorithms",
          description: "Elo, Glicko-2, MMR, and skill-based matchmaking.",
          duration: "12 min",
          hasTerminal: true,
          terminalExercise: {
            instructions: "Implement an Elo rating system that updates player ratings after matches.",
            validation: "elo|expected|k_factor|rating|update|win|loss",
          },
        },
        {
          id: "ssg-mm-2",
          title: "Lobby Systems",
          description: "Creating, joining, and managing game lobbies.",
          duration: "10 min",
          hasTerminal: false,
        },
        {
          id: "ssg-mm-3",
          title: "Queue Management",
          description: "Server allocation, queue balancing, and wait time optimization.",
          duration: "10 min",
          hasTerminal: false,
        },
      ],
      project: {
        title: "Matchmaking Service",
        description: "Build a matchmaking microservice with Elo-based rating and lobby management.",
        difficulty: "intermediate",
        estimatedHours: 6,
        skills: ["Matchmaking", "Algorithms", "APIs"],
      },
    },
    {
      id: "ssg-databases",
      title: "Game Databases & Persistence",
      description: "Storing game data, profiles, inventories, and leaderboards.",
      icon: "Database",
      trackId: "server-side-game-dev",
      order: 5,
      lessons: [
        {
          id: "ssg-db-1",
          title: "Game Data Modeling",
          description: "Schemas for players, inventories, achievements, and in-game economies.",
          duration: "12 min",
          hasTerminal: false,
        },
        {
          id: "ssg-db-2",
          title: "Redis for Game State",
          description: "Using Redis for leaderboards, sessions, and real-time data.",
          duration: "12 min",
          hasTerminal: true,
          terminalExercise: {
            instructions: "Implement a Redis-backed leaderboard with sorted sets for ranking players by score.",
            validation: "redis|zadd|zrange|zrank|leaderboard|score",
          },
        },
        {
          id: "ssg-db-3",
          title: "Save Systems & Cloud Saves",
          description: "Implementing save/load, cloud saves, and data migration.",
          duration: "10 min",
          hasTerminal: false,
        },
      ],
      project: {
        title: "Game Backend Service",
        description: "Build a backend API with player profiles, inventories, leaderboards, and cloud saves.",
        difficulty: "intermediate",
        estimatedHours: 6,
        skills: ["Databases", "Redis", "APIs"],
      },
    },
    {
      id: "ssg-scaling",
      title: "Scaling Game Infrastructure",
      description: "Scaling servers, load balancing, and global deployment.",
      icon: "Scale",
      trackId: "server-side-game-dev",
      order: 6,
      lessons: [
        {
          id: "ssg-scale-1",
          title: "Horizontal Scaling & Load Balancing",
          description: "Scaling game servers horizontally with containerization.",
          duration: "12 min",
          hasTerminal: false,
        },
        {
          id: "ssg-scale-2",
          title: "Game Server Orchestration",
          description: "Kubernetes, Agones, and container orchestration for game servers.",
          duration: "15 min",
          hasTerminal: false,
        },
        {
          id: "ssg-scale-3",
          title: "Global Deployment & Edge Computing",
          description: "Multi-region deployment for low-latency gaming worldwide.",
          duration: "10 min",
          hasTerminal: false,
        },
        {
          id: "ssg-scale-4",
          title: "Monitoring & Observability",
          description: "Metrics, logging, and alerting for game servers.",
          duration: "10 min",
          hasTerminal: false,
        },
      ],
      project: {
        title: "Scalable Game Backend",
        description: "Deploy a containerized game server with auto-scaling and monitoring.",
        difficulty: "advanced",
        estimatedHours: 8,
        skills: ["Docker", "Kubernetes", "Monitoring"],
      },
    },
    {
      id: "ssg-live-ops",
      title: "Live Ops & Game Services",
      description: "Running live games: analytics, events, updates, and monetization.",
      icon: "Activity",
      trackId: "server-side-game-dev",
      order: 7,
      lessons: [
        {
          id: "ssg-live-1",
          title: "Live Game Operations",
          description: "Patches, hotfixes, live events, and A/B testing.",
          duration: "10 min",
          hasTerminal: false,
        },
        {
          id: "ssg-live-2",
          title: "Game Analytics",
          description: "Player telemetry, retention metrics, and funnel analysis.",
          duration: "10 min",
          hasTerminal: false,
        },
        {
          id: "ssg-live-3",
          title: "In-App Purchases & Economy",
          description: "Server-side purchase validation, virtual economies, and IAP.",
          duration: "10 min",
          hasTerminal: false,
        },
      ],
      project: {
        title: "Live Ops Dashboard",
        description: "Build an admin dashboard for managing live game events, analytics, and player management.",
        difficulty: "advanced",
        estimatedHours: 6,
        skills: ["Analytics", "Dashboards", "Live Ops"],
      },
    },
  ],
};
